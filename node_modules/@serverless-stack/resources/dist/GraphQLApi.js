"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GraphQLApi = void 0;
const Api_1 = require("./Api");
const _1 = require(".");
class GraphQLApi extends Api_1.Api {
    constructor(scope, id, props) {
        // Validate server
        if (!props.server) {
            throw new Error(`Missing "server" in the "${id}" GraphQLApi`);
        }
        if ("routes" in props) {
            throw new Error(`Please use the "server" option instead of the "routes" to configure the handler for the "${id}" GraphQLApi`);
        }
        /*
        if (props.codegen) {
          const app = App.of(scope) as App;
          if (!app.local) {
            const result = spawn.sync(
              "npx",
              ["graphql-codegen", "-c", props.codegen],
              {
                stdio: "inherit",
              }
            );
            if (result.status !== 0) {
              throw new Error(
                `Failed to generate the schema for the "${id}" GraphQLApi`
              );
            }
          }
        }
        */
        const rootPath = props.rootPath || "/";
        super(scope, id, Object.assign(Object.assign({}, props), { defaultPayloadFormatVersion: props.defaultPayloadFormatVersion || _1.ApiPayloadFormatVersion.V1, routes: {
                [`GET ${rootPath}`]: props.server,
                [`POST ${rootPath}`]: props.server,
            } }));
        this.rootPath = rootPath;
        this.codegen = props.codegen;
    }
    get serverFunction() {
        const serverFn = this.getFunction(`GET ${this.rootPath}`);
        // This should never happen
        if (!serverFn) {
            throw new Error(`Failed to get "serverFunction" in the "${this.node.id}" GraphQLApi`);
        }
        return serverFn;
    }
    // Note: We want to create 1 Lambda handling both the GET and POST request.
    //       This design is based on this discussion on GitHub
    //       https://github.com/serverless-stack/serverless-stack/issues/601
    // Also Note: We cannot use the "ANY /" route because if authorization
    //            were provided, the OPTIONS route will be protected. This
    //            causes CORS to fail.
    // Solution: We will override the createFunctionIntegration() function, and
    //           it will re-use the same Route Integration for all routes.
    createFunctionIntegration(scope, routeKey, routeProps, postfixName) {
        if (!this.lambdaIntegration) {
            this.lambdaIntegration = super.createFunctionIntegration(scope, routeKey, routeProps, postfixName);
        }
        return this.lambdaIntegration;
    }
    getConstructMetadata() {
        const parent = super.getConstructMetadata();
        return Object.assign(Object.assign({}, parent), { data: Object.assign(Object.assign({}, parent.data), { graphql: true, codegen: this.codegen }) });
    }
}
exports.GraphQLApi = GraphQLApi;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiR3JhcGhRTEFwaS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9HcmFwaFFMQXBpLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUlBLCtCQUE2RDtBQUU3RCx3QkFBNEM7QUFXNUMsTUFBYSxVQUFXLFNBQVEsU0FBRztJQUtqQyxZQUFZLEtBQWdCLEVBQUUsRUFBVSxFQUFFLEtBQXNCO1FBQzlELGtCQUFrQjtRQUNsQixJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRTtZQUNqQixNQUFNLElBQUksS0FBSyxDQUFDLDRCQUE0QixFQUFFLGNBQWMsQ0FBQyxDQUFDO1NBQy9EO1FBRUQsSUFBSSxRQUFRLElBQUksS0FBSyxFQUFFO1lBQ3JCLE1BQU0sSUFBSSxLQUFLLENBQ2IsNEZBQTRGLEVBQUUsY0FBYyxDQUM3RyxDQUFDO1NBQ0g7UUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7O1VBa0JFO1FBRUYsTUFBTSxRQUFRLEdBQUcsS0FBSyxDQUFDLFFBQVEsSUFBSSxHQUFHLENBQUM7UUFFdkMsS0FBSyxDQUFDLEtBQUssRUFBRSxFQUFFLGtDQUNWLEtBQUssS0FDUiwyQkFBMkIsRUFDekIsS0FBSyxDQUFDLDJCQUEyQixJQUFJLDBCQUF1QixDQUFDLEVBQUUsRUFDakUsTUFBTSxFQUFFO2dCQUNOLENBQUMsT0FBTyxRQUFRLEVBQUUsQ0FBQyxFQUFFLEtBQUssQ0FBQyxNQUFNO2dCQUNqQyxDQUFDLFFBQVEsUUFBUSxFQUFFLENBQUMsRUFBRSxLQUFLLENBQUMsTUFBTTthQUNuQyxJQUNELENBQUM7UUFDSCxJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztRQUN6QixJQUFJLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQyxPQUFPLENBQUM7SUFDL0IsQ0FBQztJQUVELElBQVcsY0FBYztRQUN2QixNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLE9BQU8sSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUM7UUFFMUQsMkJBQTJCO1FBQzNCLElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDYixNQUFNLElBQUksS0FBSyxDQUNiLDBDQUEwQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsY0FBYyxDQUNyRSxDQUFDO1NBQ0g7UUFFRCxPQUFPLFFBQVEsQ0FBQztJQUNsQixDQUFDO0lBRUQsMkVBQTJFO0lBQzNFLDBEQUEwRDtJQUMxRCx3RUFBd0U7SUFDeEUsc0VBQXNFO0lBQ3RFLHNFQUFzRTtJQUN0RSxrQ0FBa0M7SUFDbEMsMkVBQTJFO0lBQzNFLHNFQUFzRTtJQUM1RCx5QkFBeUIsQ0FDakMsS0FBZ0IsRUFDaEIsUUFBZ0IsRUFDaEIsVUFBaUMsRUFDakMsV0FBbUI7UUFFbkIsSUFBSSxDQUFDLElBQUksQ0FBQyxpQkFBaUIsRUFBRTtZQUMzQixJQUFJLENBQUMsaUJBQWlCLEdBQUcsS0FBSyxDQUFDLHlCQUF5QixDQUN0RCxLQUFLLEVBQ0wsUUFBUSxFQUNSLFVBQVUsRUFDVixXQUFXLENBQ1osQ0FBQztTQUNIO1FBRUQsT0FBTyxJQUFJLENBQUMsaUJBQWlCLENBQUM7SUFDaEMsQ0FBQztJQUVNLG9CQUFvQjtRQUN6QixNQUFNLE1BQU0sR0FBRyxLQUFLLENBQUMsb0JBQW9CLEVBQUUsQ0FBQztRQUM1Qyx1Q0FDSyxNQUFNLEtBQ1QsSUFBSSxrQ0FDQyxNQUFNLENBQUMsSUFBSSxLQUNkLE9BQU8sRUFBRSxJQUFhLEVBQ3RCLE9BQU8sRUFBRSxJQUFJLENBQUMsT0FBTyxPQUV2QjtJQUNKLENBQUM7Q0FDRjtBQXRHRCxnQ0FzR0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBIdHRwUm91dGVJbnRlZ3JhdGlvbiB9IGZyb20gXCJAYXdzLWNkay9hd3MtYXBpZ2F0ZXdheXYyLWFscGhhXCI7XG5pbXBvcnQgeyBBcHAgfSBmcm9tIFwiLi9BcHBcIjtcbmltcG9ydCBzcGF3biBmcm9tIFwiY3Jvc3Mtc3Bhd25cIjtcbmltcG9ydCB7IENvbnN0cnVjdCB9IGZyb20gXCJjb25zdHJ1Y3RzXCI7XG5pbXBvcnQgeyBBcGksIEFwaUZ1bmN0aW9uUm91dGVQcm9wcywgQXBpUHJvcHMgfSBmcm9tIFwiLi9BcGlcIjtcbmltcG9ydCB7IEZ1bmN0aW9uIGFzIEZuLCBGdW5jdGlvbkRlZmluaXRpb24gfSBmcm9tIFwiLi9GdW5jdGlvblwiO1xuaW1wb3J0IHsgQXBpUGF5bG9hZEZvcm1hdFZlcnNpb24gfSBmcm9tIFwiLlwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIEdyYXBoUUxBcGlQcm9wcyBleHRlbmRzIE9taXQ8QXBpUHJvcHMsIFwicm91dGVzXCI+IHtcbiAgLyoqXG4gICAqIFBhdGggdG8gZ3JhcGhxbC1jb2RlZ2VuIGNvbmZpZ3VyYXRpb24gZmlsZVxuICAgKi9cbiAgY29kZWdlbj86IHN0cmluZztcbiAgc2VydmVyOiBGdW5jdGlvbkRlZmluaXRpb247XG4gIHJvb3RQYXRoPzogc3RyaW5nO1xufVxuXG5leHBvcnQgY2xhc3MgR3JhcGhRTEFwaSBleHRlbmRzIEFwaSB7XG4gIHByaXZhdGUgcmVhZG9ubHkgY29kZWdlbj86IHN0cmluZztcbiAgcHJpdmF0ZSBsYW1iZGFJbnRlZ3JhdGlvbj86IEh0dHBSb3V0ZUludGVncmF0aW9uO1xuICBwcml2YXRlIHJvb3RQYXRoPzogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBHcmFwaFFMQXBpUHJvcHMpIHtcbiAgICAvLyBWYWxpZGF0ZSBzZXJ2ZXJcbiAgICBpZiAoIXByb3BzLnNlcnZlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIFwic2VydmVyXCIgaW4gdGhlIFwiJHtpZH1cIiBHcmFwaFFMQXBpYCk7XG4gICAgfVxuXG4gICAgaWYgKFwicm91dGVzXCIgaW4gcHJvcHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFBsZWFzZSB1c2UgdGhlIFwic2VydmVyXCIgb3B0aW9uIGluc3RlYWQgb2YgdGhlIFwicm91dGVzXCIgdG8gY29uZmlndXJlIHRoZSBoYW5kbGVyIGZvciB0aGUgXCIke2lkfVwiIEdyYXBoUUxBcGlgXG4gICAgICApO1xuICAgIH1cblxuICAgIC8qXG4gICAgaWYgKHByb3BzLmNvZGVnZW4pIHtcbiAgICAgIGNvbnN0IGFwcCA9IEFwcC5vZihzY29wZSkgYXMgQXBwO1xuICAgICAgaWYgKCFhcHAubG9jYWwpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gc3Bhd24uc3luYyhcbiAgICAgICAgICBcIm5weFwiLFxuICAgICAgICAgIFtcImdyYXBocWwtY29kZWdlblwiLCBcIi1jXCIsIHByb3BzLmNvZGVnZW5dLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHN0ZGlvOiBcImluaGVyaXRcIixcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICAgIGlmIChyZXN1bHQuc3RhdHVzICE9PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEZhaWxlZCB0byBnZW5lcmF0ZSB0aGUgc2NoZW1hIGZvciB0aGUgXCIke2lkfVwiIEdyYXBoUUxBcGlgXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAqL1xuXG4gICAgY29uc3Qgcm9vdFBhdGggPSBwcm9wcy5yb290UGF0aCB8fCBcIi9cIjtcblxuICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgLi4ucHJvcHMsXG4gICAgICBkZWZhdWx0UGF5bG9hZEZvcm1hdFZlcnNpb246XG4gICAgICAgIHByb3BzLmRlZmF1bHRQYXlsb2FkRm9ybWF0VmVyc2lvbiB8fCBBcGlQYXlsb2FkRm9ybWF0VmVyc2lvbi5WMSxcbiAgICAgIHJvdXRlczoge1xuICAgICAgICBbYEdFVCAke3Jvb3RQYXRofWBdOiBwcm9wcy5zZXJ2ZXIsXG4gICAgICAgIFtgUE9TVCAke3Jvb3RQYXRofWBdOiBwcm9wcy5zZXJ2ZXIsXG4gICAgICB9LFxuICAgIH0pO1xuICAgIHRoaXMucm9vdFBhdGggPSByb290UGF0aDtcbiAgICB0aGlzLmNvZGVnZW4gPSBwcm9wcy5jb2RlZ2VuO1xuICB9XG5cbiAgcHVibGljIGdldCBzZXJ2ZXJGdW5jdGlvbigpOiBGbiB7XG4gICAgY29uc3Qgc2VydmVyRm4gPSB0aGlzLmdldEZ1bmN0aW9uKGBHRVQgJHt0aGlzLnJvb3RQYXRofWApO1xuXG4gICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuXG4gICAgaWYgKCFzZXJ2ZXJGbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRmFpbGVkIHRvIGdldCBcInNlcnZlckZ1bmN0aW9uXCIgaW4gdGhlIFwiJHt0aGlzLm5vZGUuaWR9XCIgR3JhcGhRTEFwaWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlcnZlckZuO1xuICB9XG5cbiAgLy8gTm90ZTogV2Ugd2FudCB0byBjcmVhdGUgMSBMYW1iZGEgaGFuZGxpbmcgYm90aCB0aGUgR0VUIGFuZCBQT1NUIHJlcXVlc3QuXG4gIC8vICAgICAgIFRoaXMgZGVzaWduIGlzIGJhc2VkIG9uIHRoaXMgZGlzY3Vzc2lvbiBvbiBHaXRIdWJcbiAgLy8gICAgICAgaHR0cHM6Ly9naXRodWIuY29tL3NlcnZlcmxlc3Mtc3RhY2svc2VydmVybGVzcy1zdGFjay9pc3N1ZXMvNjAxXG4gIC8vIEFsc28gTm90ZTogV2UgY2Fubm90IHVzZSB0aGUgXCJBTlkgL1wiIHJvdXRlIGJlY2F1c2UgaWYgYXV0aG9yaXphdGlvblxuICAvLyAgICAgICAgICAgIHdlcmUgcHJvdmlkZWQsIHRoZSBPUFRJT05TIHJvdXRlIHdpbGwgYmUgcHJvdGVjdGVkLiBUaGlzXG4gIC8vICAgICAgICAgICAgY2F1c2VzIENPUlMgdG8gZmFpbC5cbiAgLy8gU29sdXRpb246IFdlIHdpbGwgb3ZlcnJpZGUgdGhlIGNyZWF0ZUZ1bmN0aW9uSW50ZWdyYXRpb24oKSBmdW5jdGlvbiwgYW5kXG4gIC8vICAgICAgICAgICBpdCB3aWxsIHJlLXVzZSB0aGUgc2FtZSBSb3V0ZSBJbnRlZ3JhdGlvbiBmb3IgYWxsIHJvdXRlcy5cbiAgcHJvdGVjdGVkIGNyZWF0ZUZ1bmN0aW9uSW50ZWdyYXRpb24oXG4gICAgc2NvcGU6IENvbnN0cnVjdCxcbiAgICByb3V0ZUtleTogc3RyaW5nLFxuICAgIHJvdXRlUHJvcHM6IEFwaUZ1bmN0aW9uUm91dGVQcm9wcyxcbiAgICBwb3N0Zml4TmFtZTogc3RyaW5nXG4gICk6IEh0dHBSb3V0ZUludGVncmF0aW9uIHtcbiAgICBpZiAoIXRoaXMubGFtYmRhSW50ZWdyYXRpb24pIHtcbiAgICAgIHRoaXMubGFtYmRhSW50ZWdyYXRpb24gPSBzdXBlci5jcmVhdGVGdW5jdGlvbkludGVncmF0aW9uKFxuICAgICAgICBzY29wZSxcbiAgICAgICAgcm91dGVLZXksXG4gICAgICAgIHJvdXRlUHJvcHMsXG4gICAgICAgIHBvc3RmaXhOYW1lXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmxhbWJkYUludGVncmF0aW9uO1xuICB9XG5cbiAgcHVibGljIGdldENvbnN0cnVjdE1ldGFkYXRhKCkge1xuICAgIGNvbnN0IHBhcmVudCA9IHN1cGVyLmdldENvbnN0cnVjdE1ldGFkYXRhKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnBhcmVudCxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgLi4ucGFyZW50LmRhdGEsXG4gICAgICAgIGdyYXBocWw6IHRydWUgYXMgY29uc3QsXG4gICAgICAgIGNvZGVnZW46IHRoaXMuY29kZWdlbixcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxufVxuIl19