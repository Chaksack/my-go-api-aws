"use strict";
/* eslint-disable @typescript-eslint/ban-types */
// Note: disabling ban-type rule so we don't get an error referencing the class Function
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Function = void 0;
const path_1 = __importDefault(require("path"));
const fs = __importStar(require("fs-extra"));
const cdk = __importStar(require("aws-cdk-lib"));
const iam = __importStar(require("aws-cdk-lib/aws-iam"));
const lambda = __importStar(require("aws-cdk-lib/aws-lambda"));
const ssm = __importStar(require("aws-cdk-lib/aws-ssm"));
const Stack_1 = require("./Stack");
const permission_1 = require("./util/permission");
const core_1 = require("@serverless-stack/core");
const core_2 = require("@serverless-stack/core");
const supportedRuntimes = [
    lambda.Runtime.NODEJS,
    lambda.Runtime.NODEJS_4_3,
    lambda.Runtime.NODEJS_6_10,
    lambda.Runtime.NODEJS_8_10,
    lambda.Runtime.NODEJS_10_X,
    lambda.Runtime.NODEJS_12_X,
    lambda.Runtime.NODEJS_14_X,
    lambda.Runtime.PYTHON_2_7,
    lambda.Runtime.PYTHON_3_6,
    lambda.Runtime.PYTHON_3_7,
    lambda.Runtime.PYTHON_3_8,
    lambda.Runtime.PYTHON_3_9,
    lambda.Runtime.DOTNET_CORE_1,
    lambda.Runtime.DOTNET_CORE_2,
    lambda.Runtime.DOTNET_CORE_2_1,
    lambda.Runtime.DOTNET_CORE_3_1,
    lambda.Runtime.GO_1_X,
];
class Function extends lambda.Function {
    constructor(scope, id, props) {
        const root = scope.node.root;
        const stack = Stack_1.Stack.of(scope);
        // Merge with app defaultFunctionProps
        // note: reverse order so later prop override earlier ones
        stack.defaultFunctionProps
            .slice()
            .reverse()
            .forEach((per) => {
            props = Function.mergeProps(per, props);
        });
        // Set defaults
        const functionName = props.functionName &&
            (typeof props.functionName === "string"
                ? props.functionName
                : props.functionName({ stack, functionProps: props }));
        const handler = props.handler;
        let timeout = props.timeout || 10;
        const srcPath = Function.normalizeSrcPath(props.srcPath || ".");
        const memorySize = props.memorySize || 1024;
        const tracing = props.tracing || lambda.Tracing.ACTIVE;
        let runtime = props.runtime || lambda.Runtime.NODEJS_12_X;
        let bundle = props.bundle;
        const permissions = props.permissions;
        const isLiveDevEnabled = props.enableLiveDev === false ? false : true;
        // Validate handler
        if (!handler) {
            throw new Error(`No handler defined for the "${id}" Lambda function`);
        }
        // Normalize runtime
        const runtimeStr = typeof runtime === "string" ? runtime : runtime.toString();
        const runtimeClass = supportedRuntimes.find((per) => per.toString() === runtimeStr);
        if (!runtimeClass) {
            throw new Error(`The specified runtime is not supported for sst.Function. Only NodeJS, Python, Go, and .NET runtimes are currently supported.`);
        }
        runtime = runtimeClass;
        // Normalize timeout
        if (typeof timeout === "number") {
            timeout = cdk.Duration.seconds(timeout);
        }
        // Validate input
        const isNodeRuntime = runtimeStr.startsWith("nodejs");
        const isPythonRuntime = runtimeStr.startsWith("python");
        if (isNodeRuntime) {
            bundle = bundle === undefined ? true : props.bundle;
            if (!bundle && srcPath === ".") {
                throw new Error(`Bundle cannot be disabled for the "${id}" function since the "srcPath" is set to the project root. Read more here â€” https://github.com/serverless-stack/serverless-stack/issues/78`);
            }
        }
        else if (isPythonRuntime) {
            bundle = bundle === undefined ? {} : props.bundle;
            if (srcPath === ".") {
                throw new Error(`Cannot set the "srcPath" to the project root for the "${id}" function.`);
            }
        }
        const localId = path_1.default.posix
            .join(scope.node.path, id)
            .replace(/\$/g, "-")
            .replace(/\//g, "-");
        // Handle local development (ie. sst start)
        // - set runtime to nodejs12.x for non-Node runtimes (b/c the stub is in Node)
        // - set retry to 0. When the debugger is disconnected, the Cron construct
        //   will still try to periodically invoke the Lambda, and the requests would
        //   fail and retry. So when launching `sst start`, a couple of retry requests
        //   from recent failed request will be received. And this behavior is confusing.
        if (isLiveDevEnabled &&
            root.local &&
            root.debugEndpoint &&
            root.debugBucketName &&
            root.debugBucketArn) {
            // If debugIncreaseTimeout is enabled:
            //   set timeout to 900. This will give people more time to debug the function
            //   without timing out the request. Note API Gateway requests have a maximum
            //   timeout of 29s. In this case, the API will timeout, but the Lambda function
            //   will continue to run.
            let debugOverrideProps;
            if (root.debugIncreaseTimeout) {
                debugOverrideProps = {
                    timeout: cdk.Duration.seconds(900),
                };
            }
            if (root.debugBridge) {
                super(scope, id, Object.assign(Object.assign(Object.assign({}, props), { functionName, runtime: lambda.Runtime.GO_1_X, tracing,
                    timeout,
                    memorySize, handler: "handler", code: lambda.Code.fromAsset(path_1.default.resolve(__dirname, "../dist/bridge_client/")), environment: Object.assign(Object.assign({}, (props.environment || {})), { SST_DEBUG_BRIDGE: root.debugBridge, SST_DEBUG_SRC_PATH: srcPath, SST_DEBUG_SRC_HANDLER: handler, SST_DEBUG_ENDPOINT: root.debugEndpoint }), layers: Function.handleImportedLayers(scope, props.layers || []) }), (debugOverrideProps || {})));
            }
            else {
                super(scope, id, Object.assign(Object.assign(Object.assign({}, props), { functionName, runtime: isNodeRuntime ? runtime : lambda.Runtime.NODEJS_12_X, tracing,
                    timeout,
                    memorySize, handler: "index.main", retryAttempts: 0, code: lambda.Code.fromAsset(path_1.default.resolve(__dirname, "../dist/stub.zip")), environment: Object.assign(Object.assign({}, (props.environment || {})), { SST_DEBUG_SRC_PATH: srcPath, SST_DEBUG_SRC_HANDLER: handler, SST_DEBUG_ENDPOINT: root.debugEndpoint, SST_DEBUG_BUCKET_NAME: root.debugBucketName }), layers: Function.handleImportedLayers(scope, props.layers || []) }), (debugOverrideProps || {})));
            }
            core_1.State.Function.append(root.appPath, {
                id: localId,
                handler: handler,
                runtime: runtime.toString(),
                srcPath: srcPath,
                bundle: props.bundle,
            });
            this.addEnvironment("SST_FUNCTION_ID", localId);
            this.attachPermissions([
                new iam.PolicyStatement({
                    actions: ["s3:*"],
                    effect: iam.Effect.ALLOW,
                    resources: [root.debugBucketArn, `${root.debugBucketArn}/*`],
                }),
            ]);
        }
        // Handle remove (ie. sst remove)
        else if (root.skipBuild) {
            // Note: need to override runtime as CDK does not support inline code
            //       for some runtimes.
            super(scope, id, Object.assign(Object.assign({}, props), { functionName, runtime: lambda.Runtime.NODEJS_12_X, handler: "placeholder", code: lambda.Code.fromAsset(path_1.default.resolve(__dirname, "../assets/Function/placeholder-stub")), timeout, layers: Function.handleImportedLayers(scope, props.layers || []) }));
        }
        // Handle build
        else {
            console.log("Building function", handler);
            const bundled = core_2.Runtime.Handler.bundle({
                id: localId,
                root: root.appPath,
                handler: handler,
                runtime: runtime.toString(),
                srcPath: srcPath,
                bundle: props.bundle,
            });
            // Python builder returns AssetCode instead of directory
            const code = (() => {
                if ("directory" in bundled) {
                    Function.copyFiles(bundle, srcPath, bundled.directory);
                    return lambda.AssetCode.fromAsset(bundled.directory);
                }
                return bundled.asset;
            })();
            super(scope, id, Object.assign(Object.assign({}, props), { functionName,
                runtime,
                tracing,
                memorySize, handler: bundled.handler, code: code, timeout, layers: Function.handleImportedLayers(scope, props.layers || []) }));
        }
        // Enable reusing connections with Keep-Alive for NodeJs Lambda function
        if (isNodeRuntime) {
            this.addEnvironment("AWS_NODEJS_CONNECTION_REUSE_ENABLED", "1", {
                removeInEdge: true,
            });
        }
        // Attach permissions
        if (permissions) {
            this.attachPermissions(permissions);
        }
        root.registerLambdaHandler({
            bundle: props.bundle,
            handler: handler,
            runtime: runtime.toString(),
            srcPath,
        });
        this._isLiveDevEnabled = isLiveDevEnabled;
        this.localId = localId;
    }
    attachPermissions(permissions) {
        if (this.role) {
            (0, permission_1.attachPermissionsToRole)(this.role, permissions);
        }
    }
    getConstructMetadata() {
        return {
            type: "Function",
            data: {
                localId: this.localId,
                arn: this.functionArn,
            },
        };
    }
    static normalizeSrcPath(srcPath) {
        return srcPath.replace(/\/+$/, "");
    }
    static copyFiles(bundle, srcPath, buildPath) {
        if (!bundle)
            return;
        if (typeof bundle === "boolean")
            return;
        if (!bundle.copyFiles)
            return;
        bundle.copyFiles.forEach((entry) => {
            const fromPath = path_1.default.join(srcPath, entry.from);
            if (!fs.existsSync(fromPath))
                throw new Error(`Tried to copy nonexistent file from "${path_1.default.resolve(fromPath)}" - check copyFiles entry "${entry.from}"`);
            const to = entry.to || entry.from;
            if (path_1.default.isAbsolute(to))
                throw new Error(`Copy destination path "${to}" must be relative`);
            const toPath = path_1.default.join(buildPath, to);
            fs.copySync(fromPath, toPath);
        });
    }
    static handleImportedLayers(scope, layers) {
        return layers.map((layer) => {
            const layerStack = Stack_1.Stack.of(layer);
            const currentStack = Stack_1.Stack.of(scope);
            // Use layer directly if:
            // - layer is created in the current stack; OR
            // - layer is imported (ie. layerArn is a string)
            if (layerStack === currentStack ||
                !cdk.Token.isUnresolved(layer.layerVersionArn)) {
                return layer;
            }
            // layer is created from another stack
            else {
                // set stack dependency b/c layerStack need to create the SSM first
                currentStack.addDependency(layerStack);
                // store layer ARN in SSM in layer's stack
                const parameterId = `${layer.node.id}Arn-${layer.node.addr}`;
                const parameterName = `/layers/${layerStack.node.id}/${parameterId}`;
                const existingSsmParam = layerStack.node.tryFindChild(parameterId);
                if (!existingSsmParam) {
                    new ssm.StringParameter(layerStack, parameterId, {
                        parameterName,
                        stringValue: layer.layerVersionArn,
                    });
                }
                // import layer from SSM value
                const layerId = `I${layer.node.id}-${layer.node.addr}`;
                const existingLayer = scope.node.tryFindChild(layerId);
                if (existingLayer) {
                    return existingLayer;
                }
                else {
                    return lambda.LayerVersion.fromLayerVersionArn(scope, layerId, ssm.StringParameter.valueForStringParameter(scope, parameterName));
                }
            }
        });
    }
    static fromDefinition(scope, id, definition, inheritedProps, inheritErrorMessage) {
        if (typeof definition === "string") {
            return new Function(scope, id, Object.assign(Object.assign({}, (inheritedProps || {})), { handler: definition }));
        }
        else if (definition instanceof Function) {
            if (inheritedProps && Object.keys(inheritedProps).length > 0) {
                throw new Error(inheritErrorMessage ||
                    `Cannot inherit default props when a Function is provided`);
            }
            return definition;
        }
        else if (definition instanceof lambda.Function) {
            throw new Error(`Please use sst.Function instead of lambda.Function for the "${id}" Function.`);
        }
        else if (definition.handler !== undefined) {
            return new Function(scope, id, Function.mergeProps(inheritedProps, definition));
        }
        throw new Error(`Invalid function definition for the "${id}" Function`);
    }
    static mergeProps(baseProps, props) {
        // Merge environment
        const environment = Object.assign(Object.assign({}, ((baseProps === null || baseProps === void 0 ? void 0 : baseProps.environment) || {})), ((props === null || props === void 0 ? void 0 : props.environment) || {}));
        const environmentProp = Object.keys(environment).length === 0 ? {} : { environment };
        // Merge layers
        const layers = [...((baseProps === null || baseProps === void 0 ? void 0 : baseProps.layers) || []), ...((props === null || props === void 0 ? void 0 : props.layers) || [])];
        const layersProp = layers.length === 0 ? {} : { layers };
        // Merge permissions
        let permissionsProp;
        if ((baseProps === null || baseProps === void 0 ? void 0 : baseProps.permissions) === permission_1.PermissionType.ALL ||
            (props === null || props === void 0 ? void 0 : props.permissions) === permission_1.PermissionType.ALL) {
            permissionsProp = { permissions: permission_1.PermissionType.ALL };
        }
        else {
            const permissions = ((baseProps === null || baseProps === void 0 ? void 0 : baseProps.permissions) || []).concat((props === null || props === void 0 ? void 0 : props.permissions) || []);
            permissionsProp = permissions.length === 0 ? {} : { permissions };
        }
        return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, (baseProps || {})), (props || {})), layersProp), environmentProp), permissionsProp);
    }
}
exports.Function = Function;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRnVuY3Rpb24uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvRnVuY3Rpb24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLGlEQUFpRDtBQUNqRCx3RkFBd0Y7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRXhGLGdEQUF3QjtBQUV4Qiw2Q0FBK0I7QUFFL0IsaURBQW1DO0FBQ25DLHlEQUEyQztBQUMzQywrREFBaUQ7QUFFakQseURBQTJDO0FBSTNDLG1DQUFnQztBQUVoQyxrREFJMkI7QUFDM0IsaURBQStDO0FBQy9DLGlEQUFpRDtBQUVqRCxNQUFNLGlCQUFpQixHQUFHO0lBQ3hCLE1BQU0sQ0FBQyxPQUFPLENBQUMsTUFBTTtJQUNyQixNQUFNLENBQUMsT0FBTyxDQUFDLFVBQVU7SUFDekIsTUFBTSxDQUFDLE9BQU8sQ0FBQyxXQUFXO0lBQzFCLE1BQU0sQ0FBQyxPQUFPLENBQUMsV0FBVztJQUMxQixNQUFNLENBQUMsT0FBTyxDQUFDLFdBQVc7SUFDMUIsTUFBTSxDQUFDLE9BQU8sQ0FBQyxXQUFXO0lBQzFCLE1BQU0sQ0FBQyxPQUFPLENBQUMsV0FBVztJQUMxQixNQUFNLENBQUMsT0FBTyxDQUFDLFVBQVU7SUFDekIsTUFBTSxDQUFDLE9BQU8sQ0FBQyxVQUFVO0lBQ3pCLE1BQU0sQ0FBQyxPQUFPLENBQUMsVUFBVTtJQUN6QixNQUFNLENBQUMsT0FBTyxDQUFDLFVBQVU7SUFDekIsTUFBTSxDQUFDLE9BQU8sQ0FBQyxVQUFVO0lBQ3pCLE1BQU0sQ0FBQyxPQUFPLENBQUMsYUFBYTtJQUM1QixNQUFNLENBQUMsT0FBTyxDQUFDLGFBQWE7SUFDNUIsTUFBTSxDQUFDLE9BQU8sQ0FBQyxlQUFlO0lBQzlCLE1BQU0sQ0FBQyxPQUFPLENBQUMsZUFBZTtJQUM5QixNQUFNLENBQUMsT0FBTyxDQUFDLE1BQU07Q0FDdEIsQ0FBQztBQW9JRixNQUFhLFFBQVMsU0FBUSxNQUFNLENBQUMsUUFBUTtJQUkzQyxZQUFZLEtB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Q3pDO1lBQ0EsZUFBZSxHQUFHLEVBQUUsV0FBVyxFQUFFLDJCQUFjLENBQUMsR0FBRyxFQUFFLENBQUM7U0FDdkQ7YUFBTTtZQUNMLE1BQU0sV0FBVyxHQUFHLENBQUMsQ0FBQSxTQUFTLGFBQVQsU0FBUyx1QkFBVCxTQUFTLENBQUUsV0FBVyxLQUFJLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FDdkQsQ0FBQSxLQUFLLGFBQUwsS0FBSyx1QkFBTCxLQUFLLENBQUUsV0FBVyxLQUFJLEVBQUUsQ0FDekIsQ0FBQztZQUNGLGVBQWUsR0FBRyxXQUFXLENBQUMsTUFBTSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLFdBQVcsRUFBRSxDQUFDO1NBQ25FO1FBRUQsaUZBQ0ssQ0FBQyxTQUFTLElBQUksRUFBRSxDQUFDLEdBQ2pCLENBQUMsS0FBSyxJQUFJLEVBQUUsQ0FBQyxHQUNiLFVBQVUsR0FDVixlQUFlLEdBQ2YsZUFBZSxFQUNsQjtJQUNKLENBQUM7Q0FDRjtBQWxaRCw0QkFrWkMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzICovXG4vLyBOb3RlOiBkaXNhYmxpbmcgYmFuLXR5cGUgcnVsZSBzbyB3ZSBkb24ndCBnZXQgYW4gZXJyb3IgcmVmZXJlbmNpbmcgdGhlIGNsYXNzIEZ1bmN0aW9uXG5cbmltcG9ydCBwYXRoIGZyb20gXCJwYXRoXCI7XG5pbXBvcnQgKiBhcyBlc2J1aWxkIGZyb20gXCJlc2J1aWxkXCI7XG5pbXBvcnQgKiBhcyBmcyBmcm9tIFwiZnMtZXh0cmFcIjtcbmltcG9ydCB7IENvbnN0cnVjdCB9IGZyb20gXCJjb25zdHJ1Y3RzXCI7XG5pbXBvcnQgKiBhcyBjZGsgZnJvbSBcImF3cy1jZGstbGliXCI7XG5pbXBvcnQgKiBhcyBpYW0gZnJvbSBcImF3cy1jZGstbGliL2F3cy1pYW1cIjtcbmltcG9ydCAqIGFzIGxhbWJkYSBmcm9tIFwiYXdzLWNkay1saWIvYXdzLWxhbWJkYVwiO1xuaW1wb3J0ICogYXMgbGFtYmRhTm9kZSBmcm9tIFwiYXdzLWNkay1saWIvYXdzLWxhbWJkYS1ub2RlanNcIjtcbmltcG9ydCAqIGFzIHNzbSBmcm9tIFwiYXdzLWNkay1saWIvYXdzLXNzbVwiO1xuaW1wb3J0IGNyeXB0byBmcm9tIFwiY3J5cHRvXCI7XG5cbmltcG9ydCB7IEFwcCB9IGZyb20gXCIuL0FwcFwiO1xuaW1wb3J0IHsgU3RhY2sgfSBmcm9tIFwiLi9TdGFja1wiO1xuaW1wb3J0IHsgU1NUQ29uc3RydWN0IH0gZnJvbSBcIi4vQ29uc3RydWN0XCI7XG5pbXBvcnQge1xuICBQZXJtaXNzaW9uVHlwZSxcbiAgUGVybWlzc2lvbnMsXG4gIGF0dGFjaFBlcm1pc3Npb25zVG9Sb2xlLFxufSBmcm9tIFwiLi91dGlsL3Blcm1pc3Npb25cIjtcbmltcG9ydCB7IFN0YXRlIH0gZnJvbSBcIkBzZXJ2ZXJsZXNzLXN0YWNrL2NvcmVcIjtcbmltcG9ydCB7IFJ1bnRpbWUgfSBmcm9tIFwiQHNlcnZlcmxlc3Mtc3RhY2svY29yZVwiO1xuXG5jb25zdCBzdXBwb3J0ZWRSdW50aW1lcyA9IFtcbiAgbGFtYmRhLlJ1bnRpbWUuTk9ERUpTLFxuICBsYW1iZGEuUnVudGltZS5OT0RFSlNfNF8zLFxuICBsYW1iZGEuUnVudGltZS5OT0RFSlNfNl8xMCxcbiAgbGFtYmRhLlJ1bnRpbWUuTk9ERUpTXzhfMTAsXG4gIGxhbWJkYS5SdW50aW1lLk5PREVKU18xMF9YLFxuICBsYW1iZGEuUnVudGltZS5OT0RFSlNfMTJfWCxcbiAgbGFtYmRhLlJ1bnRpbWUuTk9ERUpTXzE0X1gsXG4gIGxhbWJkYS5SdW50aW1lLlBZVEhPTl8yXzcsXG4gIGxhbWJkYS5SdW50aW1lLlBZVEhPTl8zXzYsXG4gIGxhbWJkYS5SdW50aW1lLlBZVEhPTl8zXzcsXG4gIGxhbWJkYS5SdW50aW1lLlBZVEhPTl8zXzgsXG4gIGxhbWJkYS5SdW50aW1lLlBZVEhPTl8zXzksXG4gIGxhbWJkYS5SdW50aW1lLkRPVE5FVF9DT1JFXzEsXG4gIGxhbWJkYS5SdW50aW1lLkRPVE5FVF9DT1JFXzIsXG4gIGxhbWJkYS5SdW50aW1lLkRPVE5FVF9DT1JFXzJfMSxcbiAgbGFtYmRhLlJ1bnRpbWUuRE9UTkVUX0NPUkVfM18xLFxuICBsYW1iZGEuUnVudGltZS5HT18xX1gsXG5dO1xuXG5leHBvcnQgdHlwZSBIYW5kbGVyUHJvcHMgPSBGdW5jdGlvbkhhbmRsZXJQcm9wcztcbmV4cG9ydCB0eXBlIEZ1bmN0aW9uRGVmaW5pdGlvbiA9IHN0cmluZyB8IEZ1bmN0aW9uIHwgRnVuY3Rpb25Qcm9wcztcblxuZXhwb3J0IGludGVyZmFjZSBGdW5jdGlvblByb3BzXG4gIGV4dGVuZHMgT21pdDxsYW1iZGEuRnVuY3Rpb25PcHRpb25zLCBcImZ1bmN0aW9uTmFtZVwiIHwgXCJ0aW1lb3V0XCIgfCBcInJ1bnRpbWVcIj4ge1xuICAvKipcbiAgICogVGhlIHNvdXJjZSBkaXJlY3Rvcnkgd2hlcmUgdGhlIGVudHJ5IHBvaW50IGlzIGxvY2F0ZWQuIFRoZSBub2RlX21vZHVsZXMgaW4gdGhpc1xuICAgKiBkaXJlY3RvcnkgaXMgdXNlZCB0byBnZW5lcmF0ZSB0aGUgYnVuZGxlLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIEEgbmFtZSBmb3IgdGhlIGZ1bmN0aW9uIG9yIGEgY2FsbGJhY2sgdGhhdCByZXR1cm5zIHRoZSBuYW1lLlxuICAgKi9cbiAgZnVuY3Rpb25OYW1lPzogc3RyaW5nIHwgKChwcm9wczogRnVuY3Rpb25OYW1lUHJvcHMpID0+IHN0cmluZyk7XG4gIC8qKlxuICAgKiBQYXRoIHRvIHRoZSBlbnRyeSBwb2ludCBhbmQgaGFuZGxlciBmdW5jdGlvbi4gT2YgdGhlIGZvcm1hdDpcbiAgICogYC9wYXRoL3RvL2ZpbGUuZnVuY3Rpb25gLlxuICAgKi9cbiAgaGFuZGxlcj86IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSBzb3VyY2UgZGlyZWN0b3J5IHdoZXJlIHRoZSBlbnRyeSBwb2ludCBpcyBsb2NhdGVkLiBUaGUgbm9kZV9tb2R1bGVzIGluIHRoaXNcbiAgICogZGlyZWN0b3J5IGlzIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIGJ1bmRsZS5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBEZWZhdWx0cyB0byB0aGUgYXBwIGRpcmVjdG9yeS5cbiAgICovXG4gIHNyY1BhdGg/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgcnVudGltZSBlbnZpcm9ubWVudC5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBEZWZhdWx0cyB0byBOT0RFSlNfMTJfWFxuICAgKi9cbiAgcnVudGltZT86XG4gICAgfCBcIm5vZGVqc1wiXG4gICAgfCBcIm5vZGVqczQuM1wiXG4gICAgfCBcIm5vZGVqczYuMTBcIlxuICAgIHwgXCJub2RlanM4LjEwXCJcbiAgICB8IFwibm9kZWpzMTAueFwiXG4gICAgfCBcIm5vZGVqczEyLnhcIlxuICAgIHwgXCJub2RlanMxNC54XCJcbiAgICB8IFwicHl0aG9uMi43XCJcbiAgICB8IFwicHl0aG9uMy42XCJcbiAgICB8IFwicHl0aG9uMy43XCJcbiAgICB8IFwicHl0aG9uMy44XCJcbiAgICB8IFwicHl0aG9uMy45XCJcbiAgICB8IFwiZG90bmV0Y29yZTEuMFwiXG4gICAgfCBcImRvdG5ldGNvcmUyLjBcIlxuICAgIHwgXCJkb3RuZXRjb3JlMi4xXCJcbiAgICB8IFwiZG90bmV0Y29yZTMuMVwiXG4gICAgfCBcImdvMS54XCJcbiAgICB8IGxhbWJkYS5SdW50aW1lO1xuICAvKipcbiAgICogVGhlIGFtb3VudCBvZiBtZW1vcnkgaW4gTUIgYWxsb2NhdGVkLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIERlZmF1bHRzIHRvIDEwMjRcbiAgICovXG4gIG1lbW9yeVNpemU/OiBudW1iZXI7XG4gIC8qKlxuICAgKiBUaGUgZXhlY3V0aW9uIHRpbWVvdXQgaW4gc2Vjb25kcy5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBudW1iZXJcbiAgICovXG4gIHRpbWVvdXQ/OiBudW1iZXIgfCBjZGsuRHVyYXRpb247XG4gIC8qKlxuICAgKiBFbmFibGUgQVdTIFgtUmF5IFRyYWNpbmcuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gRGVmYXVsdHMgdG8gQUNUSVZFXG4gICAqL1xuICB0cmFjaW5nPzogbGFtYmRhLlRyYWNpbmc7XG5cbiAgLyoqXG4gICAqIEVuYWJsZSBsb2NhbCBkZXZlbG9wbWVudFxuICAgKlxuICAgKiBAZGVmYXVsdCAtIERlZmF1bHRzIHRvIHRydWVcbiAgICovXG4gIGVuYWJsZUxpdmVEZXY/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBEaXNhYmxlIGJ1bmRsaW5nIHdpdGggZXNidWlsZC5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBEZWZhdWx0cyB0byB0cnVlXG4gICAqL1xuICBidW5kbGU/OiBGdW5jdGlvbkJ1bmRsZVByb3A7XG4gIHBlcm1pc3Npb25zPzogUGVybWlzc2lvbnM7XG4gIGxheWVycz86IGxhbWJkYS5JTGF5ZXJWZXJzaW9uW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRnVuY3Rpb25OYW1lUHJvcHMge1xuICBzdGFjazogU3RhY2s7XG4gIGZ1bmN0aW9uUHJvcHM6IEZ1bmN0aW9uUHJvcHM7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRnVuY3Rpb25IYW5kbGVyUHJvcHMge1xuICBzcmNQYXRoOiBzdHJpbmc7XG4gIGhhbmRsZXI6IHN0cmluZztcbiAgYnVuZGxlOiBGdW5jdGlvbkJ1bmRsZVByb3A7XG4gIHJ1bnRpbWU6IHN0cmluZztcbn1cblxuZXhwb3J0IHR5cGUgRnVuY3Rpb25CdW5kbGVQcm9wID0gRnVuY3Rpb25CdW5kbGVPYmplY3QgfCBib29sZWFuO1xuXG5leHBvcnQgdHlwZSBGdW5jdGlvbkJ1bmRsZU9iamVjdCA9IEZ1bmN0aW9uQnVuZGxlQmFzZSAmXG4gIChGdW5jdGlvbkJ1bmRsZU5vZGVqc1Byb3BzIHwgRnVuY3Rpb25CdW5kbGVQeXRob25Qcm9wcyk7XG5cbmV4cG9ydCB0eXBlIEZ1bmN0aW9uQnVuZGxlQmFzZSA9IHtcbiAgcmVhZG9ubHkgY29weUZpbGVzPzogRnVuY3Rpb25CdW5kbGVDb3B5RmlsZXNQcm9wc1tdO1xufTtcblxuZXhwb3J0IGludGVyZmFjZSBGdW5jdGlvbkJ1bmRsZU5vZGVqc1Byb3BzIHtcbiAgbG9hZGVyPzogeyBbZXh0OiBzdHJpbmddOiBlc2J1aWxkLkxvYWRlciB9O1xuICBleHRlcm5hbE1vZHVsZXM/OiBzdHJpbmdbXTtcbiAgbm9kZU1vZHVsZXM/OiBzdHJpbmdbXTtcbiAgY29tbWFuZEhvb2tzPzogbGFtYmRhTm9kZS5JQ29tbWFuZEhvb2tzO1xuICBlc2J1aWxkQ29uZmlnPzogRnVuY3Rpb25CdW5kbGVFc2J1aWxkQ29uZmlnO1xuICBtaW5pZnk/OiBib29sZWFuO1xuICBmb3JtYXQ/OiBcImNqc1wiIHwgXCJlc21cIjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGdW5jdGlvbkJ1bmRsZVB5dGhvblByb3BzIHtcbiAgaW5zdGFsbENvbW1hbmRzPzogc3RyaW5nW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRnVuY3Rpb25CdW5kbGVDb3B5RmlsZXNQcm9wcyB7XG4gIGZyb206IHN0cmluZztcbiAgdG8/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRnVuY3Rpb25CdW5kbGVFc2J1aWxkQ29uZmlnIHtcbiAgZGVmaW5lPzogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfTtcbiAga2VlcE5hbWVzPzogYm9vbGVhbjtcbiAgcGx1Z2lucz86IHN0cmluZztcbn1cblxuZXhwb3J0IGNsYXNzIEZ1bmN0aW9uIGV4dGVuZHMgbGFtYmRhLkZ1bmN0aW9uIGltcGxlbWVudHMgU1NUQ29uc3RydWN0IHtcbiAgcHVibGljIHJlYWRvbmx5IF9pc0xpdmVEZXZFbmFibGVkOiBib29sZWFuO1xuICBwcml2YXRlIHJlYWRvbmx5IGxvY2FsSWQ6IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogRnVuY3Rpb25Qcm9wcykge1xuICAgIGNvbnN0IHJvb3QgPSBzY29wZS5ub2RlLnJvb3QgYXMgQXBwO1xuICAgIGNvbnN0IHN0YWNrID0gU3RhY2sub2Yoc2NvcGUpIGFzIFN0YWNrO1xuXG4gICAgLy8gTWVyZ2Ugd2l0aCBhcHAgZGVmYXVsdEZ1bmN0aW9uUHJvcHNcbiAgICAvLyBub3RlOiByZXZlcnNlIG9yZGVyIHNvIGxhdGVyIHByb3Agb3ZlcnJpZGUgZWFybGllciBvbmVzXG4gICAgc3RhY2suZGVmYXVsdEZ1bmN0aW9uUHJvcHNcbiAgICAgIC5zbGljZSgpXG4gICAgICAucmV2ZXJzZSgpXG4gICAgICAuZm9yRWFjaCgocGVyKSA9PiB7XG4gICAgICAgIHByb3BzID0gRnVuY3Rpb24ubWVyZ2VQcm9wcyhwZXIsIHByb3BzKTtcbiAgICAgIH0pO1xuXG4gICAgLy8gU2V0IGRlZmF1bHRzXG4gICAgY29uc3QgZnVuY3Rpb25OYW1lID1cbiAgICAgIHByb3BzLmZ1bmN0aW9uTmFtZSAmJlxuICAgICAgKHR5cGVvZiBwcm9wcy5mdW5jdGlvbk5hbWUgPT09IFwic3RyaW5nXCJcbiAgICAgICAgPyBwcm9wcy5mdW5jdGlvbk5hbWVcbiAgICAgICAgOiBwcm9wcy5mdW5jdGlvbk5hbWUoeyBzdGFjaywgZnVuY3Rpb25Qcm9wczogcHJvcHMgfSkpO1xuICAgIGNvbnN0IGhhbmRsZXIgPSBwcm9wcy5oYW5kbGVyO1xuICAgIGxldCB0aW1lb3V0ID0gcHJvcHMudGltZW91dCB8fCAxMDtcbiAgICBjb25zdCBzcmNQYXRoID0gRnVuY3Rpb24ubm9ybWFsaXplU3JjUGF0aChwcm9wcy5zcmNQYXRoIHx8IFwiLlwiKTtcbiAgICBjb25zdCBtZW1vcnlTaXplID0gcHJvcHMubWVtb3J5U2l6ZSB8fCAxMDI0O1xuICAgIGNvbnN0IHRyYWNpbmcgPSBwcm9wcy50cmFjaW5nIHx8IGxhbWJkYS5UcmFjaW5nLkFDVElWRTtcbiAgICBsZXQgcnVudGltZSA9IHByb3BzLnJ1bnRpbWUgfHwgbGFtYmRhLlJ1bnRpbWUuTk9ERUpTXzEyX1g7XG4gICAgbGV0IGJ1bmRsZSA9IHByb3BzLmJ1bmRsZTtcbiAgICBjb25zdCBwZXJtaXNzaW9ucyA9IHByb3BzLnBlcm1pc3Npb25zO1xuICAgIGNvbnN0IGlzTGl2ZURldkVuYWJsZWQgPSBwcm9wcy5lbmFibGVMaXZlRGV2ID09PSBmYWxzZSA/IGZhbHNlIDogdHJ1ZTtcblxuICAgIC8vIFZhbGlkYXRlIGhhbmRsZXJcbiAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gaGFuZGxlciBkZWZpbmVkIGZvciB0aGUgXCIke2lkfVwiIExhbWJkYSBmdW5jdGlvbmApO1xuICAgIH1cblxuICAgIC8vIE5vcm1hbGl6ZSBydW50aW1lXG4gICAgY29uc3QgcnVudGltZVN0ciA9XG4gICAgICB0eXBlb2YgcnVudGltZSA9PT0gXCJzdHJpbmdcIiA/IHJ1bnRpbWUgOiBydW50aW1lLnRvU3RyaW5nKCk7XG4gICAgY29uc3QgcnVudGltZUNsYXNzID0gc3VwcG9ydGVkUnVudGltZXMuZmluZChcbiAgICAgIChwZXIpID0+IHBlci50b1N0cmluZygpID09PSBydW50aW1lU3RyXG4gICAgKTtcbiAgICBpZiAoIXJ1bnRpbWVDbGFzcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgVGhlIHNwZWNpZmllZCBydW50aW1lIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHNzdC5GdW5jdGlvbi4gT25seSBOb2RlSlMsIFB5dGhvbiwgR28sIGFuZCAuTkVUIHJ1bnRpbWVzIGFyZSBjdXJyZW50bHkgc3VwcG9ydGVkLmBcbiAgICAgICk7XG4gICAgfVxuICAgIHJ1bnRpbWUgPSBydW50aW1lQ2xhc3M7XG5cbiAgICAvLyBOb3JtYWxpemUgdGltZW91dFxuICAgIGlmICh0eXBlb2YgdGltZW91dCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgdGltZW91dCA9IGNkay5EdXJhdGlvbi5zZWNvbmRzKHRpbWVvdXQpO1xuICAgIH1cblxuICAgIC8vIFZhbGlkYXRlIGlucHV0XG4gICAgY29uc3QgaXNOb2RlUnVudGltZSA9IHJ1bnRpbWVTdHIuc3RhcnRzV2l0aChcIm5vZGVqc1wiKTtcbiAgICBjb25zdCBpc1B5dGhvblJ1bnRpbWUgPSBydW50aW1lU3RyLnN0YXJ0c1dpdGgoXCJweXRob25cIik7XG4gICAgaWYgKGlzTm9kZVJ1bnRpbWUpIHtcbiAgICAgIGJ1bmRsZSA9IGJ1bmRsZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IHByb3BzLmJ1bmRsZTtcbiAgICAgIGlmICghYnVuZGxlICYmIHNyY1BhdGggPT09IFwiLlwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgQnVuZGxlIGNhbm5vdCBiZSBkaXNhYmxlZCBmb3IgdGhlIFwiJHtpZH1cIiBmdW5jdGlvbiBzaW5jZSB0aGUgXCJzcmNQYXRoXCIgaXMgc2V0IHRvIHRoZSBwcm9qZWN0IHJvb3QuIFJlYWQgbW9yZSBoZXJlIOKAlCBodHRwczovL2dpdGh1Yi5jb20vc2VydmVybGVzcy1zdGFjay9zZXJ2ZXJsZXNzLXN0YWNrL2lzc3Vlcy83OGBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUHl0aG9uUnVudGltZSkge1xuICAgICAgYnVuZGxlID0gYnVuZGxlID09PSB1bmRlZmluZWQgPyB7fSA6IHByb3BzLmJ1bmRsZTtcbiAgICAgIGlmIChzcmNQYXRoID09PSBcIi5cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYENhbm5vdCBzZXQgdGhlIFwic3JjUGF0aFwiIHRvIHRoZSBwcm9qZWN0IHJvb3QgZm9yIHRoZSBcIiR7aWR9XCIgZnVuY3Rpb24uYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGxvY2FsSWQgPSBwYXRoLnBvc2l4XG4gICAgICAuam9pbihzY29wZS5ub2RlLnBhdGgsIGlkKVxuICAgICAgLnJlcGxhY2UoL1xcJC9nLCBcIi1cIilcbiAgICAgIC5yZXBsYWNlKC9cXC8vZywgXCItXCIpO1xuXG4gICAgLy8gSGFuZGxlIGxvY2FsIGRldmVsb3BtZW50IChpZS4gc3N0IHN0YXJ0KVxuICAgIC8vIC0gc2V0IHJ1bnRpbWUgdG8gbm9kZWpzMTIueCBmb3Igbm9uLU5vZGUgcnVudGltZXMgKGIvYyB0aGUgc3R1YiBpcyBpbiBOb2RlKVxuICAgIC8vIC0gc2V0IHJldHJ5IHRvIDAuIFdoZW4gdGhlIGRlYnVnZ2VyIGlzIGRpc2Nvbm5lY3RlZCwgdGhlIENyb24gY29uc3RydWN0XG4gICAgLy8gICB3aWxsIHN0aWxsIHRyeSB0byBwZXJpb2RpY2FsbHkgaW52b2tlIHRoZSBMYW1iZGEsIGFuZCB0aGUgcmVxdWVzdHMgd291bGRcbiAgICAvLyAgIGZhaWwgYW5kIHJldHJ5LiBTbyB3aGVuIGxhdW5jaGluZyBgc3N0IHN0YXJ0YCwgYSBjb3VwbGUgb2YgcmV0cnkgcmVxdWVzdHNcbiAgICAvLyAgIGZyb20gcmVjZW50IGZhaWxlZCByZXF1ZXN0IHdpbGwgYmUgcmVjZWl2ZWQuIEFuZCB0aGlzIGJlaGF2aW9yIGlzIGNvbmZ1c2luZy5cbiAgICBpZiAoXG4gICAgICBpc0xpdmVEZXZFbmFibGVkICYmXG4gICAgICByb290LmxvY2FsICYmXG4gICAgICByb290LmRlYnVnRW5kcG9pbnQgJiZcbiAgICAgIHJvb3QuZGVidWdCdWNrZXROYW1lICYmXG4gICAgICByb290LmRlYnVnQnVja2V0QXJuXG4gICAgKSB7XG4gICAgICAvLyBJZiBkZWJ1Z0luY3JlYXNlVGltZW91dCBpcyBlbmFibGVkOlxuICAgICAgLy8gICBzZXQgdGltZW91dCB0byA5MDAuIFRoaXMgd2lsbCBnaXZlIHBlb3BsZSBtb3JlIHRpbWUgdG8gZGVidWcgdGhlIGZ1bmN0aW9uXG4gICAgICAvLyAgIHdpdGhvdXQgdGltaW5nIG91dCB0aGUgcmVxdWVzdC4gTm90ZSBBUEkgR2F0ZXdheSByZXF1ZXN0cyBoYXZlIGEgbWF4aW11bVxuICAgICAgLy8gICB0aW1lb3V0IG9mIDI5cy4gSW4gdGhpcyBjYXNlLCB0aGUgQVBJIHdpbGwgdGltZW91dCwgYnV0IHRoZSBMYW1iZGEgZnVuY3Rpb25cbiAgICAgIC8vICAgd2lsbCBjb250aW51ZSB0byBydW4uXG4gICAgICBsZXQgZGVidWdPdmVycmlkZVByb3BzO1xuICAgICAgaWYgKHJvb3QuZGVidWdJbmNyZWFzZVRpbWVvdXQpIHtcbiAgICAgICAgZGVidWdPdmVycmlkZVByb3BzID0ge1xuICAgICAgICAgIHRpbWVvdXQ6IGNkay5EdXJhdGlvbi5zZWNvbmRzKDkwMCksXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChyb290LmRlYnVnQnJpZGdlKSB7XG4gICAgICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgICAgIC4uLnByb3BzLFxuICAgICAgICAgIGZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICBydW50aW1lOiBsYW1iZGEuUnVudGltZS5HT18xX1gsXG4gICAgICAgICAgdHJhY2luZyxcbiAgICAgICAgICB0aW1lb3V0LFxuICAgICAgICAgIG1lbW9yeVNpemUsXG4gICAgICAgICAgaGFuZGxlcjogXCJoYW5kbGVyXCIsXG4gICAgICAgICAgY29kZTogbGFtYmRhLkNvZGUuZnJvbUFzc2V0KFxuICAgICAgICAgICAgcGF0aC5yZXNvbHZlKF9fZGlybmFtZSwgXCIuLi9kaXN0L2JyaWRnZV9jbGllbnQvXCIpXG4gICAgICAgICAgKSxcbiAgICAgICAgICBlbnZpcm9ubWVudDoge1xuICAgICAgICAgICAgLi4uKHByb3BzLmVudmlyb25tZW50IHx8IHt9KSxcbiAgICAgICAgICAgIFNTVF9ERUJVR19CUklER0U6IHJvb3QuZGVidWdCcmlkZ2UsXG4gICAgICAgICAgICBTU1RfREVCVUdfU1JDX1BBVEg6IHNyY1BhdGgsXG4gICAgICAgICAgICBTU1RfREVCVUdfU1JDX0hBTkRMRVI6IGhhbmRsZXIsXG4gICAgICAgICAgICBTU1RfREVCVUdfRU5EUE9JTlQ6IHJvb3QuZGVidWdFbmRwb2ludCxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGxheWVyczogRnVuY3Rpb24uaGFuZGxlSW1wb3J0ZWRMYXllcnMoc2NvcGUsIHByb3BzLmxheWVycyB8fCBbXSksXG4gICAgICAgICAgLi4uKGRlYnVnT3ZlcnJpZGVQcm9wcyB8fCB7fSksXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3VwZXIoc2NvcGUsIGlkLCB7XG4gICAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgICAgZnVuY3Rpb25OYW1lLFxuICAgICAgICAgIHJ1bnRpbWU6IGlzTm9kZVJ1bnRpbWUgPyBydW50aW1lIDogbGFtYmRhLlJ1bnRpbWUuTk9ERUpTXzEyX1gsXG4gICAgICAgICAgdHJhY2luZyxcbiAgICAgICAgICB0aW1lb3V0LFxuICAgICAgICAgIG1lbW9yeVNpemUsXG4gICAgICAgICAgaGFuZGxlcjogXCJpbmRleC5tYWluXCIsXG4gICAgICAgICAgcmV0cnlBdHRlbXB0czogMCxcbiAgICAgICAgICBjb2RlOiBsYW1iZGEuQ29kZS5mcm9tQXNzZXQoXG4gICAgICAgICAgICBwYXRoLnJlc29sdmUoX19kaXJuYW1lLCBcIi4uL2Rpc3Qvc3R1Yi56aXBcIilcbiAgICAgICAgICApLFxuICAgICAgICAgIGVudmlyb25tZW50OiB7XG4gICAgICAgICAgICAuLi4ocHJvcHMuZW52aXJvbm1lbnQgfHwge30pLFxuICAgICAgICAgICAgU1NUX0RFQlVHX1NSQ19QQVRIOiBzcmNQYXRoLFxuICAgICAgICAgICAgU1NUX0RFQlVHX1NSQ19IQU5ETEVSOiBoYW5kbGVyLFxuICAgICAgICAgICAgU1NUX0RFQlVHX0VORFBPSU5UOiByb290LmRlYnVnRW5kcG9pbnQsXG4gICAgICAgICAgICBTU1RfREVCVUdfQlVDS0VUX05BTUU6IHJvb3QuZGVidWdCdWNrZXROYW1lLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgbGF5ZXJzOiBGdW5jdGlvbi5oYW5kbGVJbXBvcnRlZExheWVycyhzY29wZSwgcHJvcHMubGF5ZXJzIHx8IFtdKSxcbiAgICAgICAgICAuLi4oZGVidWdPdmVycmlkZVByb3BzIHx8IHt9KSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBTdGF0ZS5GdW5jdGlvbi5hcHBlbmQocm9vdC5hcHBQYXRoLCB7XG4gICAgICAgIGlkOiBsb2NhbElkLFxuICAgICAgICBoYW5kbGVyOiBoYW5kbGVyLFxuICAgICAgICBydW50aW1lOiBydW50aW1lLnRvU3RyaW5nKCksXG4gICAgICAgIHNyY1BhdGg6IHNyY1BhdGgsXG4gICAgICAgIGJ1bmRsZTogcHJvcHMuYnVuZGxlLFxuICAgICAgfSk7XG4gICAgICB0aGlzLmFkZEVudmlyb25tZW50KFwiU1NUX0ZVTkNUSU9OX0lEXCIsIGxvY2FsSWQpO1xuICAgICAgdGhpcy5hdHRhY2hQZXJtaXNzaW9ucyhbXG4gICAgICAgIG5ldyBpYW0uUG9saWN5U3RhdGVtZW50KHtcbiAgICAgICAgICBhY3Rpb25zOiBbXCJzMzoqXCJdLFxuICAgICAgICAgIGVmZmVjdDogaWFtLkVmZmVjdC5BTExPVyxcbiAgICAgICAgICByZXNvdXJjZXM6IFtyb290LmRlYnVnQnVja2V0QXJuLCBgJHtyb290LmRlYnVnQnVja2V0QXJufS8qYF0sXG4gICAgICAgIH0pLFxuICAgICAgXSk7XG4gICAgfVxuICAgIC8vIEhhbmRsZSByZW1vdmUgKGllLiBzc3QgcmVtb3ZlKVxuICAgIGVsc2UgaWYgKHJvb3Quc2tpcEJ1aWxkKSB7XG4gICAgICAvLyBOb3RlOiBuZWVkIHRvIG92ZXJyaWRlIHJ1bnRpbWUgYXMgQ0RLIGRvZXMgbm90IHN1cHBvcnQgaW5saW5lIGNvZGVcbiAgICAgIC8vICAgICAgIGZvciBzb21lIHJ1bnRpbWVzLlxuICAgICAgc3VwZXIoc2NvcGUsIGlkLCB7XG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICBmdW5jdGlvbk5hbWUsXG4gICAgICAgIHJ1bnRpbWU6IGxhbWJkYS5SdW50aW1lLk5PREVKU18xMl9YLFxuICAgICAgICBoYW5kbGVyOiBcInBsYWNlaG9sZGVyXCIsXG4gICAgICAgIGNvZGU6IGxhbWJkYS5Db2RlLmZyb21Bc3NldChcbiAgICAgICAgICBwYXRoLnJlc29sdmUoX19kaXJuYW1lLCBcIi4uL2Fzc2V0cy9GdW5jdGlvbi9wbGFjZWhvbGRlci1zdHViXCIpXG4gICAgICAgICksXG4gICAgICAgIHRpbWVvdXQsXG4gICAgICAgIGxheWVyczogRnVuY3Rpb24uaGFuZGxlSW1wb3J0ZWRMYXllcnMoc2NvcGUsIHByb3BzLmxheWVycyB8fCBbXSksXG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gSGFuZGxlIGJ1aWxkXG4gICAgZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkJ1aWxkaW5nIGZ1bmN0aW9uXCIsIGhhbmRsZXIpO1xuICAgICAgY29uc3QgYnVuZGxlZCA9IFJ1bnRpbWUuSGFuZGxlci5idW5kbGUoe1xuICAgICAgICBpZDogbG9jYWxJZCxcbiAgICAgICAgcm9vdDogcm9vdC5hcHBQYXRoLFxuICAgICAgICBoYW5kbGVyOiBoYW5kbGVyLFxuICAgICAgICBydW50aW1lOiBydW50aW1lLnRvU3RyaW5nKCksXG4gICAgICAgIHNyY1BhdGg6IHNyY1BhdGgsXG4gICAgICAgIGJ1bmRsZTogcHJvcHMuYnVuZGxlLFxuICAgICAgfSkhO1xuXG4gICAgICAvLyBQeXRob24gYnVpbGRlciByZXR1cm5zIEFzc2V0Q29kZSBpbnN0ZWFkIG9mIGRpcmVjdG9yeVxuICAgICAgY29uc3QgY29kZSA9ICgoKSA9PiB7XG4gICAgICAgIGlmIChcImRpcmVjdG9yeVwiIGluIGJ1bmRsZWQpIHtcbiAgICAgICAgICBGdW5jdGlvbi5jb3B5RmlsZXMoYnVuZGxlLCBzcmNQYXRoLCBidW5kbGVkLmRpcmVjdG9yeSk7XG4gICAgICAgICAgcmV0dXJuIGxhbWJkYS5Bc3NldENvZGUuZnJvbUFzc2V0KGJ1bmRsZWQuZGlyZWN0b3J5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVuZGxlZC5hc3NldDtcbiAgICAgIH0pKCk7XG5cbiAgICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgZnVuY3Rpb25OYW1lLFxuICAgICAgICBydW50aW1lLFxuICAgICAgICB0cmFjaW5nLFxuICAgICAgICBtZW1vcnlTaXplLFxuICAgICAgICBoYW5kbGVyOiBidW5kbGVkLmhhbmRsZXIsXG4gICAgICAgIGNvZGU6IGNvZGUhLFxuICAgICAgICB0aW1lb3V0LFxuICAgICAgICBsYXllcnM6IEZ1bmN0aW9uLmhhbmRsZUltcG9ydGVkTGF5ZXJzKHNjb3BlLCBwcm9wcy5sYXllcnMgfHwgW10pLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gRW5hYmxlIHJldXNpbmcgY29ubmVjdGlvbnMgd2l0aCBLZWVwLUFsaXZlIGZvciBOb2RlSnMgTGFtYmRhIGZ1bmN0aW9uXG4gICAgaWYgKGlzTm9kZVJ1bnRpbWUpIHtcbiAgICAgIHRoaXMuYWRkRW52aXJvbm1lbnQoXCJBV1NfTk9ERUpTX0NPTk5FQ1RJT05fUkVVU0VfRU5BQkxFRFwiLCBcIjFcIiwge1xuICAgICAgICByZW1vdmVJbkVkZ2U6IHRydWUsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBBdHRhY2ggcGVybWlzc2lvbnNcbiAgICBpZiAocGVybWlzc2lvbnMpIHtcbiAgICAgIHRoaXMuYXR0YWNoUGVybWlzc2lvbnMocGVybWlzc2lvbnMpO1xuICAgIH1cblxuICAgIHJvb3QucmVnaXN0ZXJMYW1iZGFIYW5kbGVyKHtcbiAgICAgIGJ1bmRsZTogcHJvcHMuYnVuZGxlISxcbiAgICAgIGhhbmRsZXI6IGhhbmRsZXIsXG4gICAgICBydW50aW1lOiBydW50aW1lLnRvU3RyaW5nKCksXG4gICAgICBzcmNQYXRoLFxuICAgIH0pO1xuICAgIHRoaXMuX2lzTGl2ZURldkVuYWJsZWQgPSBpc0xpdmVEZXZFbmFibGVkO1xuICAgIHRoaXMubG9jYWxJZCA9IGxvY2FsSWQ7XG4gIH1cblxuICBwdWJsaWMgYXR0YWNoUGVybWlzc2lvbnMocGVybWlzc2lvbnM6IFBlcm1pc3Npb25zKTogdm9pZCB7XG4gICAgaWYgKHRoaXMucm9sZSkge1xuICAgICAgYXR0YWNoUGVybWlzc2lvbnNUb1JvbGUodGhpcy5yb2xlIGFzIGlhbS5Sb2xlLCBwZXJtaXNzaW9ucyk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGdldENvbnN0cnVjdE1ldGFkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkZ1bmN0aW9uXCIgYXMgY29uc3QsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGxvY2FsSWQ6IHRoaXMubG9jYWxJZCxcbiAgICAgICAgYXJuOiB0aGlzLmZ1bmN0aW9uQXJuLFxuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIG5vcm1hbGl6ZVNyY1BhdGgoc3JjUGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gc3JjUGF0aC5yZXBsYWNlKC9cXC8rJC8sIFwiXCIpO1xuICB9XG5cbiAgc3RhdGljIGNvcHlGaWxlcyhcbiAgICBidW5kbGU6IEZ1bmN0aW9uQnVuZGxlUHJvcCB8IHVuZGVmaW5lZCxcbiAgICBzcmNQYXRoOiBzdHJpbmcsXG4gICAgYnVpbGRQYXRoOiBzdHJpbmdcbiAgKSB7XG4gICAgaWYgKCFidW5kbGUpIHJldHVybjtcbiAgICBpZiAodHlwZW9mIGJ1bmRsZSA9PT0gXCJib29sZWFuXCIpIHJldHVybjtcbiAgICBpZiAoIWJ1bmRsZS5jb3B5RmlsZXMpIHJldHVybjtcblxuICAgIGJ1bmRsZS5jb3B5RmlsZXMuZm9yRWFjaCgoZW50cnkpID0+IHtcbiAgICAgIGNvbnN0IGZyb21QYXRoID0gcGF0aC5qb2luKHNyY1BhdGgsIGVudHJ5LmZyb20pO1xuICAgICAgaWYgKCFmcy5leGlzdHNTeW5jKGZyb21QYXRoKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBUcmllZCB0byBjb3B5IG5vbmV4aXN0ZW50IGZpbGUgZnJvbSBcIiR7cGF0aC5yZXNvbHZlKFxuICAgICAgICAgICAgZnJvbVBhdGhcbiAgICAgICAgICApfVwiIC0gY2hlY2sgY29weUZpbGVzIGVudHJ5IFwiJHtlbnRyeS5mcm9tfVwiYFxuICAgICAgICApO1xuICAgICAgY29uc3QgdG8gPSBlbnRyeS50byB8fCBlbnRyeS5mcm9tO1xuICAgICAgaWYgKHBhdGguaXNBYnNvbHV0ZSh0bykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29weSBkZXN0aW5hdGlvbiBwYXRoIFwiJHt0b31cIiBtdXN0IGJlIHJlbGF0aXZlYCk7XG4gICAgICBjb25zdCB0b1BhdGggPSBwYXRoLmpvaW4oYnVpbGRQYXRoLCB0byk7XG4gICAgICBmcy5jb3B5U3luYyhmcm9tUGF0aCwgdG9QYXRoKTtcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBoYW5kbGVJbXBvcnRlZExheWVycyhcbiAgICBzY29wZTogQ29uc3RydWN0LFxuICAgIGxheWVyczogbGFtYmRhLklMYXllclZlcnNpb25bXVxuICApOiBsYW1iZGEuSUxheWVyVmVyc2lvbltdIHtcbiAgICByZXR1cm4gbGF5ZXJzLm1hcCgobGF5ZXIpID0+IHtcbiAgICAgIGNvbnN0IGxheWVyU3RhY2sgPSBTdGFjay5vZihsYXllcik7XG4gICAgICBjb25zdCBjdXJyZW50U3RhY2sgPSBTdGFjay5vZihzY29wZSk7XG4gICAgICAvLyBVc2UgbGF5ZXIgZGlyZWN0bHkgaWY6XG4gICAgICAvLyAtIGxheWVyIGlzIGNyZWF0ZWQgaW4gdGhlIGN1cnJlbnQgc3RhY2s7IE9SXG4gICAgICAvLyAtIGxheWVyIGlzIGltcG9ydGVkIChpZS4gbGF5ZXJBcm4gaXMgYSBzdHJpbmcpXG4gICAgICBpZiAoXG4gICAgICAgIGxheWVyU3RhY2sgPT09IGN1cnJlbnRTdGFjayB8fFxuICAgICAgICAhY2RrLlRva2VuLmlzVW5yZXNvbHZlZChsYXllci5sYXllclZlcnNpb25Bcm4pXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGxheWVyO1xuICAgICAgfVxuICAgICAgLy8gbGF5ZXIgaXMgY3JlYXRlZCBmcm9tIGFub3RoZXIgc3RhY2tcbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBzZXQgc3RhY2sgZGVwZW5kZW5jeSBiL2MgbGF5ZXJTdGFjayBuZWVkIHRvIGNyZWF0ZSB0aGUgU1NNIGZpcnN0XG4gICAgICAgIGN1cnJlbnRTdGFjay5hZGREZXBlbmRlbmN5KGxheWVyU3RhY2spO1xuICAgICAgICAvLyBzdG9yZSBsYXllciBBUk4gaW4gU1NNIGluIGxheWVyJ3Mgc3RhY2tcbiAgICAgICAgY29uc3QgcGFyYW1ldGVySWQgPSBgJHtsYXllci5ub2RlLmlkfUFybi0ke2xheWVyLm5vZGUuYWRkcn1gO1xuICAgICAgICBjb25zdCBwYXJhbWV0ZXJOYW1lID0gYC9sYXllcnMvJHtsYXllclN0YWNrLm5vZGUuaWR9LyR7cGFyYW1ldGVySWR9YDtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdTc21QYXJhbSA9IGxheWVyU3RhY2subm9kZS50cnlGaW5kQ2hpbGQocGFyYW1ldGVySWQpO1xuICAgICAgICBpZiAoIWV4aXN0aW5nU3NtUGFyYW0pIHtcbiAgICAgICAgICBuZXcgc3NtLlN0cmluZ1BhcmFtZXRlcihsYXllclN0YWNrLCBwYXJhbWV0ZXJJZCwge1xuICAgICAgICAgICAgcGFyYW1ldGVyTmFtZSxcbiAgICAgICAgICAgIHN0cmluZ1ZhbHVlOiBsYXllci5sYXllclZlcnNpb25Bcm4sXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW1wb3J0IGxheWVyIGZyb20gU1NNIHZhbHVlXG4gICAgICAgIGNvbnN0IGxheWVySWQgPSBgSSR7bGF5ZXIubm9kZS5pZH0tJHtsYXllci5ub2RlLmFkZHJ9YDtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdMYXllciA9IHNjb3BlLm5vZGUudHJ5RmluZENoaWxkKGxheWVySWQpO1xuICAgICAgICBpZiAoZXhpc3RpbmdMYXllcikge1xuICAgICAgICAgIHJldHVybiBleGlzdGluZ0xheWVyIGFzIGxhbWJkYS5MYXllclZlcnNpb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGxhbWJkYS5MYXllclZlcnNpb24uZnJvbUxheWVyVmVyc2lvbkFybihcbiAgICAgICAgICAgIHNjb3BlLFxuICAgICAgICAgICAgbGF5ZXJJZCxcbiAgICAgICAgICAgIHNzbS5TdHJpbmdQYXJhbWV0ZXIudmFsdWVGb3JTdHJpbmdQYXJhbWV0ZXIoc2NvcGUsIHBhcmFtZXRlck5hbWUpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIGZyb21EZWZpbml0aW9uKFxuICAgIHNjb3BlOiBDb25zdHJ1Y3QsXG4gICAgaWQ6IHN0cmluZyxcbiAgICBkZWZpbml0aW9uOiBGdW5jdGlvbkRlZmluaXRpb24sXG4gICAgaW5oZXJpdGVkUHJvcHM/OiBGdW5jdGlvblByb3BzLFxuICAgIGluaGVyaXRFcnJvck1lc3NhZ2U/OiBzdHJpbmdcbiAgKTogRnVuY3Rpb24ge1xuICAgIGlmICh0eXBlb2YgZGVmaW5pdGlvbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbihzY29wZSwgaWQsIHtcbiAgICAgICAgLi4uKGluaGVyaXRlZFByb3BzIHx8IHt9KSxcbiAgICAgICAgaGFuZGxlcjogZGVmaW5pdGlvbixcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoZGVmaW5pdGlvbiBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICBpZiAoaW5oZXJpdGVkUHJvcHMgJiYgT2JqZWN0LmtleXMoaW5oZXJpdGVkUHJvcHMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGluaGVyaXRFcnJvck1lc3NhZ2UgfHxcbiAgICAgICAgICAgIGBDYW5ub3QgaW5oZXJpdCBkZWZhdWx0IHByb3BzIHdoZW4gYSBGdW5jdGlvbiBpcyBwcm92aWRlZGBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWZpbml0aW9uO1xuICAgIH0gZWxzZSBpZiAoZGVmaW5pdGlvbiBpbnN0YW5jZW9mIGxhbWJkYS5GdW5jdGlvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgUGxlYXNlIHVzZSBzc3QuRnVuY3Rpb24gaW5zdGVhZCBvZiBsYW1iZGEuRnVuY3Rpb24gZm9yIHRoZSBcIiR7aWR9XCIgRnVuY3Rpb24uYFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKChkZWZpbml0aW9uIGFzIEZ1bmN0aW9uUHJvcHMpLmhhbmRsZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbihcbiAgICAgICAgc2NvcGUsXG4gICAgICAgIGlkLFxuICAgICAgICBGdW5jdGlvbi5tZXJnZVByb3BzKGluaGVyaXRlZFByb3BzLCBkZWZpbml0aW9uKVxuICAgICAgKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGZ1bmN0aW9uIGRlZmluaXRpb24gZm9yIHRoZSBcIiR7aWR9XCIgRnVuY3Rpb25gKTtcbiAgfVxuXG4gIHN0YXRpYyBtZXJnZVByb3BzKFxuICAgIGJhc2VQcm9wcz86IEZ1bmN0aW9uUHJvcHMsXG4gICAgcHJvcHM/OiBGdW5jdGlvblByb3BzXG4gICk6IEZ1bmN0aW9uUHJvcHMge1xuICAgIC8vIE1lcmdlIGVudmlyb25tZW50XG4gICAgY29uc3QgZW52aXJvbm1lbnQgPSB7XG4gICAgICAuLi4oYmFzZVByb3BzPy5lbnZpcm9ubWVudCB8fCB7fSksXG4gICAgICAuLi4ocHJvcHM/LmVudmlyb25tZW50IHx8IHt9KSxcbiAgICB9O1xuICAgIGNvbnN0IGVudmlyb25tZW50UHJvcCA9XG4gICAgICBPYmplY3Qua2V5cyhlbnZpcm9ubWVudCkubGVuZ3RoID09PSAwID8ge30gOiB7IGVudmlyb25tZW50IH07XG5cbiAgICAvLyBNZXJnZSBsYXllcnNcbiAgICBjb25zdCBsYXllcnMgPSBbLi4uKGJhc2VQcm9wcz8ubGF5ZXJzIHx8IFtdKSwgLi4uKHByb3BzPy5sYXllcnMgfHwgW10pXTtcbiAgICBjb25zdCBsYXllcnNQcm9wID0gbGF5ZXJzLmxlbmd0aCA9PT0gMCA/IHt9IDogeyBsYXllcnMgfTtcblxuICAgIC8vIE1lcmdlIHBlcm1pc3Npb25zXG4gICAgbGV0IHBlcm1pc3Npb25zUHJvcDtcbiAgICBpZiAoXG4gICAgICBiYXNlUHJvcHM/LnBlcm1pc3Npb25zID09PSBQZXJtaXNzaW9uVHlwZS5BTEwgfHxcbiAgICAgIHByb3BzPy5wZXJtaXNzaW9ucyA9PT0gUGVybWlzc2lvblR5cGUuQUxMXG4gICAgKSB7XG4gICAgICBwZXJtaXNzaW9uc1Byb3AgPSB7IHBlcm1pc3Npb25zOiBQZXJtaXNzaW9uVHlwZS5BTEwgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcGVybWlzc2lvbnMgPSAoYmFzZVByb3BzPy5wZXJtaXNzaW9ucyB8fCBbXSkuY29uY2F0KFxuICAgICAgICBwcm9wcz8ucGVybWlzc2lvbnMgfHwgW11cbiAgICAgICk7XG4gICAgICBwZXJtaXNzaW9uc1Byb3AgPSBwZXJtaXNzaW9ucy5sZW5ndGggPT09IDAgPyB7fSA6IHsgcGVybWlzc2lvbnMgfTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uKGJhc2VQcm9wcyB8fCB7fSksXG4gICAgICAuLi4ocHJvcHMgfHwge30pLFxuICAgICAgLi4ubGF5ZXJzUHJvcCxcbiAgICAgIC4uLmVudmlyb25tZW50UHJvcCxcbiAgICAgIC4uLnBlcm1pc3Npb25zUHJvcCxcbiAgICB9O1xuICB9XG59XG4iXX0=